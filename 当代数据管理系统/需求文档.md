### 项目描述：

实现一个提供网上购书功能的网站后端。网站支持书商在上面开商店，购买者可以通过网站购买。买家和卖家都可以注册自己的账号。一个卖家可以开一个或多个网上商店，买家可以为自己的账户充值，在任意商店购买图书。

功能上需要支持 下单->付款->发货->收货 流程。

数据库使用postgresql关系型数据库。

目前已经完成代码部分，正在写实验报告。实验报告包括实验目标、数据库设计、代码实现、实验总结四个部分，需要你完成**数据库设计**部分的撰写。

### 功能介绍：

这一部分介绍一下每个接口是怎么操作数据库的，为你写数据库相关功能，添加索引等提供依据。

#### 用户权限接口

注册：先在user表内查询表中是否已经存在用户输入的user_id，如果没有，就在user表中添加一条数据，根据当前时间生成terminal和token，刚刚注册的用户初始金额为0.

登录：在user表内查询所输入user_id对应的password，如果用户名不存在或密码不正确，返回权限错误，如果存在的话，在user表内查询所输入user_id对应的token和terminal，将这两个表示对应用户权限的值返回，此后用户请求在headers使用这两个值就可以标明处于在线状态。

登出：先查询user表，检查user_id和token是否存在且对应，然后根据当前时间戳生成新的terminal和token。

注销：查询user表，检查输入的用户名和密码是否存在且匹配，如果是就从user表中删除user_id对应的记录。

#### 买家用户接口

下单：先查询user表，检查用户是否存在，再查询user_store表，检查商店是否存在，然后遍历用户给出的book_id和count列表，查询store表，检查每本书在商店里是否存在、书本数目是否充足，如果符合要求就扣除书店中的库存，然后创建订单详细信息，其中每本书对应new_order_detail表中的一条记录，将所有书本的价格累加，最后在new_order表中创建一条记录，将status设置为unpaid，created_time为当前时间，表示订单创建成功。

充值：查询user表，查看用户是否存在，password是否匹配，如果存在且匹配就修改这条记录，在balance属性上增加用户输入的add_value。

付款：查询new_order表，确认订单号存在，然后确认订单对应的user_id是否与用户输入的user_id相对应，并检查订单状态是否正确，如果是paid、cancelled、shipped、received就返回订单状态错误。检查user表中输入的user_id和passwd是否存在且匹配，并获取用户当前的balance。如果balance小于订单的总价，就返回错误信息，没有足够的金额，如果足够付款，就从balance中扣除总价，并将订单状态更新为paid。

#### 卖家用户接口

创建店铺：先查询user表，检查输入的卖家id是否存在，然后查询user_store表，检查输入的store_id是否已经被创建过，如果都没有，就可以在user_store表中创建一条新的数据，包含store_id（唯一）和user_id（不唯一，因为多个用户可以创建多个商店）。

添加书籍信息及描述：检查user_id、store_id的存在之后，查询user_store表并匹配输入的store_id，检查book_id在这个商店中是否存在，如果不存在，则查询book表，如果book表中存在对应的id，则表示这本书存在于别的商店里，则不需要再次插入到book表中，只需要在store表中插入一条记录即可，这条记录包含store_id，book_id，price和stock_level。如果这本书也不存在与book表中，则在book表中要插入详细的记录，记录的各项属性由用户输入的book_json决定。

增加库存：查询user表和user_store表，检查用户和商店是否存在，然后查询store表，检查book_id是否存在于特定商店中。如果存在，那么对于store表中的对应记录，将stock_level添加指定的个数即可。

#### 发货收货流程

卖家发货：先检查对应的store_id是否存在，如果存在，就查询new_order表，找到order_id和store_id对应的记录，如果订单不存在则报错，订单状态为shipped，就返回200并声明订单已经发货，如果订单状态不为paid，那么就返回状态错误，此外，就将订单状态设为shipped，并记录发货时间即可。

买家收货：查询new_order表，查看order_id是否存在，确认user_id是否匹配，检查订单状态，如果状态为received，就返回200，并提示当前订单已经收货，如果订单状态不是shipped（已发货状态），就返回状态错误。如果状态为shipped，就将状态更新为received，并记录收货时间。

#### 图书搜索功能

店内搜索：首先将`store_alias` 和 `book_alias` 创建为 `StoreModel` 和 `BookModel` 的别名，以便在后续的查询中使用，然后构建一个基本的查询 `query`，关联了 `StoreModel` 和 `BookModel` 表，过滤条件是 `store_id` 等于给定的 `store_id`，根据提供的可选搜索条件，逐一添加过滤条件到查询中。如果有传递的条件（如 title、author、publisher 等），则将相应的 ilike 过滤条件添加到查询中。如果传递了 `tags` 列表，使用循环为每个标签添加过滤条件，确保图书的标签包含列表中的任何标签。计算查询的分页结果，通过 `query.all()` 获取所有结果，然后使用切片操作 (`[skip: skip + limit]`) 获取指定页数和每页数量的子集。遍历分页结果，将每本图书的相关信息构建成一个字典，并添加到结果列表中。返回查询结果，如果没有异常发生，返回状态码 200 和查询结果列表。如果发生异常，打印异常信息，并返回状态码 530 和异常描述字符串。

全网搜索：`search_all` 函数接收一系列搜索条件（如标题、作者、出版商等），以及分页参数（页数和每页数量）。通过 SQLAlchemy 构建了一个基本的查询 `query`，该查询目标是 `BookModel` 表。根据传递的搜索条件，逐一添加 ilike 过滤条件到查询中，以实现模糊搜索。如果条件存在，则在相应的列上添加 ilike 过滤条件。如果传递了 `tags` 列表，使用循环为每个标签添加 ilike 过滤条件，确保图书的标签包含列表中的任何标签。计算查询的分页结果，通过 `query.all()` 获取所有结果，然后使用切片操作 (`[skip: skip + limit]`) 获取指定页数和每页数量的子集。如果查询结果的总数小于等于分页的结束位置（`skip + limit`），则获取所有结果；否则，获取指定范围内的子集。将分页结果中的每本图书的相关信息构建成一个字典，并添加到结果列表中。返回查询结果，如果没有异常发生，返回状态码 200 和查询结果列表。如果发生异常，打印异常信息，并返回状态码 530 和异常描述字符串。

#### 订单查询和取消

买家订单查询：查询new_order表，并匹配有着输入的user_id的记录，将这些订单的信息作为字典返回。

卖家订单查询：由于一个用户可以开设多个店铺，因此首先查询user_store，找到用户输入的user_id所开设的所有店铺的store_id，然后遍历这些store_id，在new_order中查询每个store_id，然后将得到的订单信息放入列表中，最后返回这些订单信息。

用户取消订单：首先检查order_id和user_id是否存在且匹配，然后检查订单状态，只有还没发货的订单可以取消，因此如果订单为shipped和received，就返回状态错误。如果订单已经取消了就返回200并提示订单已经被取消了。如果订单状态是paid，就需要将付款退回给用户，这时需要查询new_order_detail表，根据order_id找到订单所需的总钱数，然后查询用户id，更新用户余额，并将订单状态更新为cancelled。

自动取消订单：`OrderAutoCancel` 类在初始化时调用了 `db_conn.DBConn` 的构造函数，建立了数据库连接，并创建了一个定时器 `cancel_timer`。定时器 `cancel_timer` 被设置为每隔 60 秒执行一次 `cancel_unpaid_orders` 方法，即自动取消超过一分钟未支付的订单。在类的构造函数中，启动了定时器，并输出 "First start" 提示信息。`cancel_unpaid_orders` 方法被定时器执行，首先获取当前时间，并计算出一个时间间隔（1分钟前的时间）。通过查询数据库，找到所有状态为 'unpaid' 且创建时间在指定时间间隔之前的订单。这些订单被视为超时未支付的订单。遍历未支付订单列表，将每个订单的状态更新为 'cancelled'，并提交事务。如果在执行过程中出现异常，打印错误信息，但不中断程序执行。在方法执行结束后，重新设置定时器 `cancel_timer`，以便下一次定时执行，并输出 "Second start" 提示信息。

为了实现订单自动取消，`cancel_unpaid_orders`方法获取当前时间，并查询`new_order`表，找到所有订单创建时间距离现在超过1分钟的订单，然后将状态设置为cancelled。方法结束前，还会重新建立一个线程，在60秒后再调用这个方法。这里的60秒可以改到更小的值，从而更频繁地轮询`new_order`表，更及时找出超时的订单并取消。该功能的实现也可以通过给每个订单都加一个定时器，但本项目为了效率的要求，60秒才执行一次轮询，可以保证一个超时的订单在超时2分钟之内一定会被取消。

### 目标需求：

描述本项目是如何正确地使用数据库和设计分析工具，ER图，从ER图导出关系模式，规范化，事务处理，索引等，进行关系数据库设计的。